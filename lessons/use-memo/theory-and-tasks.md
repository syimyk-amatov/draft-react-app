# React Практика: useMemo Hook

## 1. Теория

### Проблема (Expensive Calculations & Referential Equality)
В React компоненты перерисовываются при каждом изменении состояния или пропсов. Если внутри компонента выполняется тяжелая вычислительная операция (например, сложная фильтрация большого массива, факториал, парсинг данных), она будет запускаться при **каждом** рендере, даже если данные для неё не изменились. Это замедляет интерфейс.

Кроме того, как и в случае с `useCallback`, объекты и массивы, созданные внутри компонента, при каждом рендере являются новыми ссылками. Это может вызывать лишние рендеры дочерних компонентов (даже если они обернуты в `React.memo`) или ненужные срабатывания `useEffect`.

### Решение (useMemo)
`useMemo` позволяет мемоизировать (кешировать) *результат* вычисления. Функция внутри `useMemo` будет выполнена повторно только тогда, когда изменятся зависимости.

```tsx
const memoizedValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]); // Пересчет только если a или b изменились
```

---

## 2. Задача 1: Аналитика транзакций (Expensive Analytics)

В реальных дашбордах часто приходится агрегировать данные на клиенте (суммировать, группировать, фильтровать). Это может быть "тяжелой" операцией, если данных много.

### Сценарий
У вас есть список финансовых транзакций (1000+ элементов). Вам нужно подсчитывать общую сумму и группировать их по категориям для отображения статистики. При этом в интерфейсе есть "мелкие" взаимодействия (например, переключение темы или вкладки), которые не должны запускать пересчет всей статистики.

### Требования:
1.  Создайте компонент `TransactionAnalytics`.
2.  **Данные**:
    *   Сгенерируйте массив из 1000 транзакций при монтировании (или вне компонента): `{ id: 1, amount: 100, category: 'Food' }`. Сделайте суммы и категории случайными.
3.  **Состояние**:
    *   `isDarkTheme`: булево (для имитации ненужного ререндера).
    *   `transactions`: сам массив данных.
4.  **Логика**:
    *   Создайте функцию `calculateStats(transactions)`, которая:
        *   Считает общую сумму.
        *   Считает сумму по каждой категории (Food, Travel, Work).
        *   **Важно**: Добавьте искуственную задержку `while(performance.now() - start < 500) {}` или просто `console.log('Recalculating stats...')`, чтобы имитировать тяжесть вычислений.
    *   Вызовите эту функцию внутри компонента и отобразите результаты.
    *   Добавьте кнопку переключения темы.
5.  **Проблема**:
    *   При нажатии на кнопку темы интерфейс "фризит" (подвисает) на полсекунды (или вы видите лог), потому что `calculateStats` запускается заново.
6.  **Решение**:
    *   Оберните вычисление статистики в `useMemo`.
    *   Зависимость: `transactions`.
    *   Проверьте: переключение темы теперь происходит мгновенно/без логов.

---

## 3. Задача 2: Стабилизация конфига графика (Referential Equality)

Это классическая ошибка при работе с библиотеками графиков (Recharts, Chart.js) или картами (Google Maps), которые чувствительны к ссылкам на пропсы.

### Сценарий
У нас есть компонент `ComplexChart`, который очень дорого рендерить (он обернут в `React.memo`). Мы передаем ему объект настроек `options` и массив `data`. Если ссылка на `options` меняется, график полностью перерисовывается, сбрасывая анимации и зум.

### Требования:
1.  Создайте компонент `ChartDashboard`.
2.  **Компонент `ComplexChart`** (Ребенок):
    *   Принимает `options` (объект) и `series` (массив чисел).
    *   Обернут в `React.memo`.
    *   Внутри рендера: `console.log("--- CHART FULL RERENDER ---")`.
    *   Возвращает `div` с текстом "График (см. консоль)".
3.  **Компонент `ChartDashboard`** (Родитель):
    *   Состояние `range`: число (контролирует инпут type="range" от 1 до 100).
    *   Состояние `chartType`: строка ('bar' | 'line').
4.  **Логика**:
    *   Создайте объект настроек внутри рендера родителя:
        ```javascript
        const chartOptions = {
          type: chartType, // зависит от стейта
          color: 'blue',
          grid: true,
          animation: { duration: 500 }
        };
        ```
    *   Создайте массив данных (пусть он будет статичным или зависит от чего-то другого).
    *   Передайте `chartOptions` в `ComplexChart`.
5.  **Наблюдение**:
    *   Двигайте ползунок `range` (который вообще не касается графика!).
    *   Смотрите в консоль: График перерисовывается при КЖДОМ движении ползунка.
    *   *Причина*: `chartOptions` создается заново (новый объект в памяти) при каждом рендере `ChartDashboard`.
6.  **Решение**:
    *   Используйте `useMemo` для создания `chartOptions`.
    *   Зависимости: `[chartType]`.
    *   Проверьте: при изменении `range` график молчит. При переключении `chartType` график обновляется.
