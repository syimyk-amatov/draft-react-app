# React Практика: useCallback Hook

## 1. Теория

### Проблема (Referential Equality & Re-renders)
В JavaScript функции являются объектами. Каждый раз, когда компонент React рендерится, все функции, объявленные внутри него, создаются заново. 

```javascript
// При каждом рендере Parent эта функция - НОВЫЙ объект в памяти
const handleClick = () => { ... };
```

Это становится проблемой, когда:
1.  Мы передаем эту функцию в дочерний компонент, обернутый в `React.memo` (оптимизированный компонент). Так как ссылка на функцию меняется, `React.memo` считает, что пропсы изменились, и выполняет лишний рендер ребенка.
2.  Функция используется в массиве зависимостей `useEffect` или другого хука.

### Решение (useCallback)
`useCallback` запоминает (мемоизирует) саму функцию и возвращает одну и ту же ссылку на неё между рендерами, пока не изменятся зависимости.

```tsx
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b], // Функция пересоздастся только если изменятся a или b
);
```

---

## 2. Задача 1: Оптимизация списка (Средняя сложность)

Вам нужно оптимизировать рендеринг списка задач.

### Сценарий
У нас есть список задач и кнопка "Удалить" возле каждой. При вводе текста в поле поиска, весь список не должен перерисовываться, если сами задачи не менялись.

### Требования:
1.  Создайте структуру:
    *   `src/lessons/use-callback/TodoList.tsx`
2.  **Компоненты**:
    *   `TodoItem` (Ребенок): Принимает `task` (строка) и `onDelete` (функция).
        *   **Важно**: Оберните этот компонент в `React.memo`!
        *   Добавьте `console.log("Render Item:", task)` внутрь компонента, чтобы видеть, когда он рендерится.
    *   `TodoList` (Родитель):
        *   Состояние `todos`: массив строк `['Task 1', 'Task 2', 'Task 3']`.
        *   Состояние `term`: строка для поля ввода (фильтр/поиск, но фильтрацию реализовывать не обязательно, главное - сам ввод).
        *   Инпут, связанный с `term`.
        *   Рендер списка `todos` с помощью `TodoItem`.
3.  **Логика**:
    *   Реализуйте функцию `handleDelete`.
    *   Сначала передайте её в `TodoItem` **без** `useCallback`.
    *   Попробуйте вводить текст в инпут. Обратите внимание в консоли, что все `TodoItem` рендерятся при каждом нажатии клавиши, хотя список задач не менялся!
    *   **Исправление**: Оберните `handleDelete` в `useCallback`.
    *   Проверьте снова: при вводе текста в инпут, сообщения "Render Item" больше не должны появляться в консоли.

---

## 3. Задача 2: Генератор паролей с историей (Сложная)

В этой задаче нужно аккуратно управлять зависимостями, чтобы избежать бесконечных циклов и устаревших замыканий (stale closures).

### Сценарий
Приложение генерирует случайные пароли. Мы хотим сохранять последние 5 сгенерированных паролей в историю.

### Требования:
1.  Создайте компонент `PasswordGenerator`.
2.  **Состояние**:
    *   `password`: текущий сгенерированный пароль.
    *   `history`: массив последних 5 паролей.
    *   `length`: длина пароля (инпут type="number").
3.  **Логика**:
    *   Создайте функцию `generatePassword`. Она должна:
        1.  Генерировать случайную строку заданной длины `length`.
        2.  Обновлять `password`.
        3.  Добавлять этот новый пароль в начало `history` (оставляя только топ-5).
    *   **Важно**: Оберните `generatePassword` в `useCallback`.
    *   Кнопка "Сгенерировать" вызывает эту функцию.
    *   Добавьте `useEffect`, который вызывает `generatePassword` **один раз** при монтировании компонента (авто-генерация при входе).
4.  **Сложность (Ловушка)**:
    *   Если вы добавите `history` или `password` в зависимости `useCallback`, а затем вызовете эту функцию внутри `useEffect` (который тоже зависит от неё), вы можете получить бесконечный цикл обновлений или устаревшие данные.
    *   **Задача**: Реализуйте `generatePassword` так, чтобы она корректно обновляла и текущий пароль, и историю, зависела от `length`, но при этом не ломала `useEffect` и не создавала бесконечных циклов.
    *   *Подсказка*: Используйте функциональное обновление состояния `setHistory(prev => ...)`.

---
