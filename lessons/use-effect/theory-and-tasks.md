# React Практика: useEffect Hook

## 1. Теория

### Проблема (Side Effects)
Функциональные компоненты React по своей природе должны быть "чистыми": они принимают пропсы и возвращают JSX. Однако приложениям часто нужно выполнять "побочные эффекты" (side effects):
- Запросы к API (Data fetching).
- Подписки на события.
- Изменение DOM вручную (например, `document.title`).
- Таймеры и интервалы.

### Решение (useEffect)
Хук `useEffect` позволяет выполнять побочные эффекты в функциональных компонентах. Он служит заменой методам жизненного цикла классов (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).

### Основные части:
1.  **Callback**: Функция с логикой эффекта.
2.  **Dependency Array** (Массив зависимостей): Управляет тем, *когда* эффект запускается.
3.  **Cleanup Function** (Функция очистки): Возвращается из колбэка и запускается перед следующим запуском эффекта или при размонтировании.

```tsx
useEffect(() => {
  // 1. Логика эффекта (выполняется после рендера)
  const timer = setInterval(() => console.log('Tick'), 1000);

  // 3. Очистка (выполняется перед следующим эффектом или unmount)
  return () => {
    clearInterval(timer);
  };
}, [/* 2. Зависимости */]); // [a, b] -> перезапуск, если a или b изменились
```

---

## 2. Задача 1: Простой эффект (Заголовок документа)

Вам нужно создать компонент, который синхронизирует состояние счетчика с заголовком вкладки браузера.

### Требования:
1.  Создайте компонент `DocumentTitleCounter`.
2.  Добавьте состояние `count` (число) и кнопку для его увеличения.
3.  Используйте `useEffect`:
    *   При каждом изменении `count` обновляйте `document.title` текстом: `"Вы нажали {count} раз"`.
4.  Проверьте работу: нажимайте кнопку и следите за вкладкой браузера.

---

## 3. Задача 2: Таймер бездействия (Idle Timer)

В этой задаче вы реализуете таймер, который отслеживает активность пользователя. Если пользователь не двигает мышкой в течение 5 секунд, приложение считает его "неактивным".

### Сценарий
Мы создаем компонент безопасности, который следит за активностью пользователя.

### Требования:
1.  Создайте компонент `IdleTimer`.
2.  **Состояние**:
    *   `seconds`: счетчик времени, прошедшего с момента последнего действия (изначально 0).
    *   `isActive`: булево значение (изначально `true`).
3.  **Логика**:
    *   **Эффект 1 (Таймер)**: Запустите интервал, который увеличивает `seconds` каждую секунду.
        *   Если `seconds` >= 5, установите `isActive` в `false`.
        *   Не забудьте очистить интервал при размонтировании!
    *   **Эффект 2 (Слушатель событий)**: Подпишитесь на событие `mousemove` на `window`.
        *   При движении мыши сбрасывайте `seconds` в 0 и устанавливайте `isActive` в `true`.
        *   **Важно**: Обязательно удаляйте слушатель события (`removeEventListener`) в функции очистки, чтобы не замедлять браузер.
4.  **Рендер**:
    *   Если `isActive` === `true`: Показывайте "Пользователь активен".
    *   Если `isActive` === `false`: Показывайте "Вы здесь? (Нет активности 5+ сек)".
    *   Отображайте текущее значение таймера для отладки (`seconds`).

### Сложность:
Вам придется комбинировать `setInterval` и `addEventListener`. Будьте внимательны с зависимостями эффектов, чтобы не создавать лишних переподписок.
