# React Практика: useMemo Hook

## 1. Теория

### Проблема (Expensive Calculations & Referential Equality)
В React компоненты перерисовываются при каждом изменении состояния или пропсов. Если внутри компонента выполняется тяжелая вычислительная операция (например, сложная фильтрация большого массива, факториал, парсинг данных), она будет запускаться при **каждом** рендере, даже если данные для неё не изменились. Это замедляет интерфейс.

Кроме того, как и в случае с `useCallback`, объекты и массивы, созданные внутри компонента, при каждом рендере являются новыми ссылками. Это может вызывать лишние рендеры дочерних компонентов (даже если они обернуты в `React.memo`) или ненужные срабатывания `useEffect`.

### Решение (useMemo)
`useMemo` позволяет мемоизировать (кешировать) *результат* вычисления. Функция внутри `useMemo` будет выполнена повторно только тогда, когда изменятся зависимости.

```tsx
const memoizedValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]); // Пересчет только если a или b изменились
```

---

## 2. Задача 1: Аналитика транзакций (Expensive Analytics)

В реальных дашбордах часто приходится агрегировать данные на клиенте (суммировать, группировать, фильтровать). Это может быть "тяжелой" операцией, если данных много.

### Сценарий
У вас есть список финансовых транзакций (1000+ элементов). Вам нужно подсчитывать общую сумму и группировать их по категориям для отображения статистики. При этом в интерфейсе есть "мелкие" взаимодействия (например, переключение темы или вкладки), которые не должны запускать пересчет всей статистики.

### Требования:
1.  Создайте компонент `TransactionAnalytics`.
2.  **Данные**:
    *   Сгенерируйте массив из 1000 транзакций при монтировании (или вне компонента): `{ id: 1, amount: 100, category: 'Food' }`. Сделайте суммы и категории случайными.
3.  **Состояние**:
    *   `isDarkTheme`: булево (для имитации ненужного ререндера).
    *   `transactions`: сам массив данных.
4.  **Логика**:
    *   Создайте функцию `calculateStats(transactions)`, которая:
        *   Считает общую сумму.
        *   Считает сумму по каждой категории (Food, Travel, Work).
        *   **Важно**: Добавьте искуственную задержку `while(performance.now() - start < 500) {}` или просто `console.log('Recalculating stats...')`, чтобы имитировать тяжесть вычислений.
    *   Вызовите эту функцию внутри компонента и отобразите результаты.
    *   Добавьте кнопку переключения темы.
5.  **Проблема**:
    *   При нажатии на кнопку темы интерфейс "фризит" (подвисает) на полсекунды (или вы видите лог), потому что `calculateStats` запускается заново.
6.  **Решение**:
    *   Оберните вычисление статистики в `useMemo`.
    *   Зависимость: `transactions`.
    *   Проверьте: переключение темы теперь происходит мгновенно/без логов.

---

## 3. Задача 2: Колонки таблицы и Referential Equality

Частая ошибка при использовании UI-китов (MUI, AntD) или самописных таблиц. Мы передаем конфигурацию колонок как массив объектов. Если этот массив создается внутри рендера, он всегда *новый* по ссылке, что заставляет таблицу перерисовываться полностью, даже если данные не менялись.

### Сценарий
Есть компонент `SmartTable`, который принимает данные (`data`) и настройки колонок (`columns`). Таблица обернута в `React.memo`, так как рендеринг 100+ строк — это дорого. Рядом с таблицей есть инпут поиска или фильтр, который обновляет состояние родителя.

### Требования:
1.  Создайте компонент `TableDashboard`.
2.  **Компонент `SmartTable`** (Ребенок):
    *   Принимает пропсы: `data` (массив) и `columns` (массив объектов).
    *   Обернут в `React.memo`.
    *   Внутри рендера вешает `console.log("--- TABLE RENDERED ---")`.
    *   Рендерит простую HTML таблицу.
3.  **Компонент `TableDashboard`** (Родитель):
    *   **Состояние `viewMode`**: 'comfortable' | 'compact' (вид "Плотность"). Этот переключатель влияет, например, на стиль контейнера или класс вокруг таблицы, но НЕ меняет колонки и данные.
    *   **Состояние `filter`**: строка (поиск по имени).
    *   **Данные**: Статический массив пользователей (5-10 шт) внутри компонента или снаружи.
4.  **Логика проблемы**:
    *   Внутри рендера родителя (`TableDashboard`) подготовьте данные:
        *   `filteredData`: фильтрация исходного массива по `filter`.
    *   Внутри рендера родителя создайте конфигурацию колонок:
        ```javascript
        // ПРОБЛЕМА ТУТ: Этот массив создается заново при КАЖДОМ рендере родителя
        const columns = [
          { id: 'name', title: 'Name', width: 200 },
          { id: 'role', title: 'Role', width: 100 },
          { id: 'active', title: 'Is Active', width: 80 }
        ];
        ```
    *   Передайте `filteredData` и `columns` в `SmartTable`.
5.  **Наблюдение**:
    *   Переключите `viewMode` ("Плотность").
    *   Данные таблицы НЕ изменились. Колонки визуально НЕ изменились (допустим, класс меняется на обертке).
    *   Но в консоли: `--- TABLE RENDERED ---`.
    *   *Причина*: `columns` — это новая ссылка, поэтому `React.memo` считает, что пропсы изменились.
6.  **Решение**:
    *   Оберните создание `columns` в `useMemo`.
    *   Зависимости: `[]`.
    *   Проверьте: при переключении `viewMode` лога в консоли БЫТЬ НЕ ДОЛЖНО. При вводе в поиск (`filter`) лог ДОЛЖЕН быть (так как меняется `data`).
