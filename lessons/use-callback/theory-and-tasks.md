# React Практика: useCallback Hook

## 1. Теория

### Проблема (Referential Equality)
В JavaScript функции являются объектами. Каждый раз, когда функциональный компонент рендерится, все функции, объявленные внутри него, **создаются заново**. Они имеют разную ссылку в памяти, даже если их код абсолютно одинаков.

```javascript
/* Рендер 1 */ const handleClick = () => {};
/* Рендер 2 */ const handleClick = () => {}; // Это НОВАЯ функция, отличная от предыдущей
```

Это становится проблемой, если:
1.  Вы передаете эту функцию в дочерний компонент, обернутый в `React.memo` (он перерисуется, думая, что пропсы изменились).
2.  Функция используется в массиве зависимостей `useEffect` другого хука.

### Решение (useCallback)
`useCallback` — это хук, который **мемоизирует** (кэширует) саму функцию. Он возвращает одну и ту же ссылку на функцию между рендерами, пока не изменятся зависимости.

### Синтаксис:
```tsx
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b], // Массив зависимостей: если a или b изменятся, функция пересоздастся
);
```

---

## 2. Задача 1: Список дел с оптимизацией (Средняя сложность)

В этой задаче вы увидите, как отсутствие `useCallback` убивает оптимизацию `React.memo`.

### Сценарий
У нас есть большой список задач. Каждый элемент списка — это отдельный компонент `TodoItem`. Мы хотим, чтобы при удалении одной задачи *остальные* не перерисовывались.

### Требования:
1.  Создайте папку `lessons/use-callback/todo-list` и файлы `TodoList.tsx` (родитель) и `TodoItem.tsx` (ребенок).
2.  **Child Component (`TodoItem`)**:
    *   Принимает пропсы: `id`, `text`, `onDelete` (функция).
    *   **Важно**: Оберните этот компонент в `React.memo`, чтобы он рендерился только при изменении пропсов.
    *   Добавьте `console.log('Rendering Item:', text)` внутрь компонента, чтобы видеть, когда он рендерится.
3.  **Parent Component (`TodoList`)**:
    *   Состояние: массив задач `[{ id: 1, text: "Learn React" }, ...]`.
    *   Состояние: текстовое поле для ввода новой задачи (чтобы вызывать ре-рендер родителя при вводе).
    *   Функция `handleDelete`: принимает `id` и удаляет задачу из состояния.
4.  **Эксперимент**:
    *   Передайте `handleDelete` в `TodoItem`.
    *   Попробуйте вводить текст в инпут родителя. Если `handleDelete` **не** обернут в `useCallback`, вы увидите в консоли кучу логов `Rendering Item...`, хотя список задач не менялся!
5.  **Fix**:
    *   Оберните `handleDelete` в `useCallback`. Теперь ввод текста в инпуте не должен вызывать ре-рендер списка задач.

---

## 3. Задача 2: Генератор паролей "на лету" (Сложная)

В этой задаче вы столкнетесь с проблемой "устаревших замыканий" (stale closures) внутри `useCallback` и научитесь их обходить.

### Сценарий
Вы создаете генератор паролей. У вас есть настройки (длина, цифры, символы) и кнопка "Сгенерировать". Но также вы хотите, чтобы пароль генерировался **при каждом изменении настроек** автоматически.

### Требования:
1.  Создайте папку `lessons/use-callback/password-generator` и компонент `PasswordGenerator.tsx`.
2.  **Состояние**:
    *   `length` (число, input type="range").
    *   `includeNumbers` (boolean, checkbox).
    *   `includeSymbols` (boolean, checkbox).
    *   `password` (строка, результат).
3.  **Функция `generatePassword`**:
    *   Логика: генерирует случайную строку на основе текущих `length`, `includeNumbers`, `includeSymbols`.
    *   Эта функция должна быть обернута в `useCallback`.
4.  **Два режима вызова**:
    *   **Ручной**: Кнопка "Сгенерировать новый", которая вызывает `generatePassword`.
    *   **Автоматический**: `useEffect`, который вызывает `generatePassword` при изменении настроек.
5.  **Проблема (Задача)**:
    *   Чтобы использовать `generatePassword` внутри `useEffect`, вы должны добавить её в зависимости: `useEffect(..., [generatePassword])`.
    *   Если вы просто добавите все состояния (`length`, и т.д.) в зависимости `useCallback`, то функция будет пересоздаваться при каждом чихе, и `useEffect` будет срабатывать постоянно (это нормально, но мы хотим оптимизации).
    *   **Challenge**: Попробуйте реализовать `Button` (отдельный компонент, обернутый в `React.memo`) для кнопки генерации. Если `generatePassword` постоянно меняется, кнопка будет постоянно ре-рендериться.
6.  **Цель**:
    *   Добиться того, чтобы изменение настроек обновляло пароль.
    *   Но! Нажатие на кнопку "Сгенерировать" (при неизменных настройках) должно вызывать ту же самую мемоизированную функцию.

**Подсказка для профи**: Зависимости — это самое сложное в `useCallback`. Если ваша функция зависит от состояния, она *обязана* включать его в зависимости, иначе она "запомнит" старые значения навсегда.
