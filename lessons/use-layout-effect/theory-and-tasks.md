# React Практика: useLayoutEffect Hook

## 1. Теория

### Проблема (Flicker & Layout Thrashing)
Хук `useEffect` запускается **асинхронно**, *после* того, как браузер перерисовал экран (paint). Это хорошо для производительности, но иногда вызывает визуальные проблемы:
- **Мерцание (Flicker)**: Пользователь видит начальное состояние компонента на долю секунды, прежде чем эффект изменит его.
- **Сдвиг макета (Layout Shift)**: Элементы прыгают, если эффект меняет их размер или положение.

### Решение (useLayoutEffect)
`useLayoutEffect` имеет ту же сигнатуру, что и `useEffect`, но запускается **синхронно**, сразу после того, как React обновил DOM, но *до* того, как браузер отрисовал эти изменения на экране.

Это позволяет вам читать из DOM (например, ширину элемента) и синхронно перезаписывать его, предотвращая лишнюю отрисовку промежуточного состояния.

```tsx
useLayoutEffect(() => {
  // 1. Измеряем элемент в DOM
  const { height } = ref.current.getBoundingClientRect();
  
  // 2. Меняем что-то (например, скроллим)
  if (height > 100) {
      setTooTall(true); 
  }
  // Браузер НЕ отрисует кадр, пока этот код не выполнится.
}, []);
```

**Когда использовать:**
- Вычисление геометрии (размеров, положения) элементов для позиционирования (например, тултипы).
- Предотвращение мерцания при изменении DOM сразу после рендера.

**Когда НЕ использовать:**
- Для запросов данных или подписок (это замедлит отображение интерфейса). Используйте `useEffect`.

---

## 2. Задача 1: Позиционирование Tooltip (Средняя)

В этой задаче нужно позиционировать всплывающую подсказку относительно кнопки так, чтобы она не "прыгала" при появлении.

### Сценарий
У нас есть кнопка. При наведении на неё появляется Tooltip. Мы не знаем заранее высоту Tooltip (она зависит от текста). Мы хотим, чтобы Tooltip появлялся строго *над* кнопкой.

### Требования:
1.  Создайте папку `src/lessons/use-layout-effect` и компонент `Tooltip.tsx`.
2.  **Компоненты**:
    *   `Tooltip`: Принимает `text` и `targetRect` (координаты элемента, над которым нужно показать).
    *   `TooltipDemo`: Родительский компонент с кнопкой.
3.  **Логика**:
    *   В `TooltipDemo` отслеживайте состояние `show` (boolean) и `targetRect` (DOMRect кнопки).
    *   Используйте `onMouseEnter` на кнопке, чтобы получить её координаты (`e.target.getBoundingClientRect()`) и показать Tooltip.
    *   В компоненте `Tooltip`:
        *   Используйте `useRef` для доступа к DOM-элементу самого тултипа.
        *   Используйте `useLayoutEffect`:
            1. Измерьте высоту тултипа.
            2. Установите его позицию `top` так, чтобы он был *над* кнопкой (targetRect.top - tooltipHeight).
    *   **Сравнение**: Попробуйте заменить `useLayoutEffect` на `useEffect`. При быстром появлении/скрытии или сложной верстке вы можете заметить микро-мигание (тултип сначала рендерится в дефолтном месте, потом прыгает).

---

## 3. Задача 2: Блокировка "плохого" значения (Сложная)

Имитация ситуации, когда мы должны скорректировать данные перед тем, как пользователь их увидит.

### Сценарий
У нас есть счетчик, который обновляется случайным образом. Но наше приложение "не поддерживает" числа больше 300. Если выпадает > 300, мы должны мгновенно сбросить значение до 300.

### Требования:
1.  Создайте компонент `BlinkingCounter`.
2.  **Логика**:
    *   Кнопка "Add Random", которая добавляет случайное число (0-500) к текущему счетчику.
    *   Отображение текущего `value`.
    *   **Задача**:
        *   Если `value` становится больше 300, оно должно "обрезаться" до 0 (или 300).
        *   Реализуйте это сначала с `useEffect`. Вы увидите "мерцание": сначала появится число 450, а через мгновение оно сменится на 0. Это плохой UX.
        *   Замените на `useLayoutEffect`. Теперь браузер не отрисует кадр с "450". Пользователь увидит сразу скорректированное значение, хотя в React state изменение прошло в два этапа.
3.  **Дополнение**:
    *   Добавьте искусственную задержку (тяжелые вычисления) внутри рендера компонента (например, цикл `for` на 10мс), чтобы эффект мерцания с `useEffect` был более заметен.
